const isNumber = require('is-number');

const Sketch = require('./Sketch');
const Vector = require('./Vector');
const HParam = require('./HParam');

/**
 * a + (vx)*i + (vy)*j + (vz)*k
 * definition from dsc.h:18
 * @member Number w
 * @member Number vx
 * @member Number vy
 * @member Number vz
 *
 * definition from dsc.h:25
 * implementation from util.cpp:298
 * @param Number w
 * @param Number vx
 * @param Number vy
 * @param Number vz
 *
 * definition from dsc.h:26
 * implementation from util.cpp:307
 * @param HParam w
 * @param HParam vx
 * @param HParam vy
 * @param HParam vz
 *
 * definition from dsc.h:27
 * implementation from util.cpp:327
 * @param Vector u
 * @param Vector v
 *
 * definition from dsc.h:28
 * implementation from util.cpp:316
 * @param Vector axis
 * @param Number dTheta
 */
function Quaternion(arg0, arg1, arg2, arg3, arg4) {
  const argList = [arg0, arg1, arg2, arg3];
  if (argList.every(isNumber)) {
    this.w = arg0;
    this.vx = arg1;
    this.vy = arg2;
    this.vz = arg3;
  } else if (argList.every(arg => arg instanceof HParam) && arg4 instanceof Sketch) {
    const sketch = arg4;
    this.w = sketch.getParam(arg0).val;
    this.vx = sketch.getParam(arg1).val;
    this.vy = sketch.getParam(arg2).val;
    this.vz = sketch.getParam(arg3).val;
  } else if (arg0 instanceof Vector && arg1 instanceof Vector) {
    const u = arg0;
    const v = arg1;
    const n = u.cross(v);

    const tr = 1 + u.x + v.y + n.z;
    if (tr > 1e-4) {
      const s = 2 * Math.sqrt(tr);
      this.w = s / 4;
      this.vx = (v.z - n.y) / s;
      this.vy = (n.x - u.z) / s;
      this.vz = (u.y - v.x) / s;
    } else if (u.x > v.y && u.x > n.z) {
      const s = 2 * Math.sqrt((1 + u.x) - v.y - n.z);
      this.w = (v.z - n.y) / s;
      this.vx = s / 4;
      this.vy = (u.y + v.x) / s;
      this.vz = (n.x + u.z) / s;
    } else if (v.y > n.z) {
      const s = 2 * Math.sqrt(1 - (u.x + v.y) - n.z);
      this.w = (n.x - u.z) / s;
      this.vx = (u.y + v.x) / s;
      this.vy = s / 4;
      this.vz = (v.z + n.y) / s;
    } else {
      const s = 2 * Math.sqrt(1 - u.x - (v.y + n.z));
      this.w = (u.y - v.x) / s;
      this.vx = (n.x + u.z) / s;
      this.vy = (v.z + n.y) / s;
      this.vz = s / 4;
    }
    return this.withMagnitude(1);
  } else if (arg0 instanceof Vector && isNumber(arg1)) {
    const dtheta = arg1;
    const c = Math.cos(dtheta / 2);
    const s = Math.sin(dtheta / 2);
    const axis = arg0.withMagnitude(s);
    this.w = c;
    this.vx = axis.x;
    this.vy = axis.y;
    this.vz = axis.z;
  } else {
    throw new Error('invalid arguments provided');
  }
}

/**
 * definition from dsc.h:23
 * implementation from util.cpp:296
 */
Quaternion.IDENTITY = new Quaternion(1, 0, 0, 0);


/**
 * definition from dsc.h:
 * implementation from util.cpp:364
 * @param Quaternion b
 * @returns Quaternion
 */
Quaternion.prototype.plus = function plus(b) {
  return new Quaternion(
    this.w + b.w,
    this.vx + b.vx,
    this.vy + b.vy,
    this.vz + b.vz
  );
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:373
 * @param Quaternion b
 * @returns Quaternion
 */
Quaternion.prototype.minus = function minus(b) {
  return new Quaternion(
    this.w - b.w,
    this.vx - b.vx,
    this.vy - b.vy,
    this.vz - b.vz
  );
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:382
 * @param double s
 * @returns Quaternion
 */
Quaternion.prototype.scaledBy = function scaledBy(s) {
  return new Quaternion(
    this.w * s,
    this.vx * s,
    this.vy * s,
    this.vz * s
  );
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:391
 * @returns double
 */
Quaternion.prototype.magnitude = function magnitude() {
  return Math.sqrt(
    (this.w * this.w) +
    (this.vx * this.vx) +
    (this.vy * this.vy) +
    (this.vz * this.vz)
  );
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:395
 * @param double s
 * @returns Quaternion
 */
Quaternion.prototype.withMagnitude = function withMagnitude(s) {
  return this.scaledBy(s / this.magnitude());
};


// Call a rotation matrix [ u' v' n' ]'; this returns the first and
// second rows, where that matrix is generated by this quaternion
/**
 * definition from dsc.h:
 * implementation from util.cpp:399
 * @returns Vector
 */
Quaternion.prototype.rotationU = function rotationU() {
  const { w, vx, vy, vz } = this;
  return new Vector(
    ((w * w) + (vx * vx)) - (vy * vy) - (vz * vz),
    (2 * w * vz) + (2 * vx * vy),
    (2 * vx * vz) - (2 * w * vy)
  );
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:407
 * @returns Vector
 */
Quaternion.prototype.rotationV = function rotationV() {
  const { w, vx, vy, vz } = this;
  return new Vector(
    (2 * vx * vy) - (2 * w * vz),
    ((w * w) + (vy * vy)) - (vx * vx) - (vz * vz),
    (2 * w * vx) + (2 * vy * vz)
  );
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:415
 * @returns Vector
 */
Quaternion.prototype.rotationN = function rotationN() {
  const { w, vx, vy, vz } = this;
  return new Vector(
    (2 * w * vy) + (2 * vx * vz),
    (2 * vy * vz) - (2 * w * vx),
    ((w * w) - (vx * vx) - (vy * vy)) + (vz * vz)
  );
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:423
 * @param Vector p
 * @returns Vector
 */
Quaternion.prototype.rotate = function rotate(p) {
  // Express the point in the new basis
  return (this.rotationU().scaledBy(p.x)).plus(
          this.rotationV().scaledBy(p.y)).plus(
          this.rotationN().scaledBy(p.z));
};


/**
 * definition from dsc.h:
 * implementation from util.cpp:439
 * @param double p
 * @returns Quaternion
 */
Quaternion.prototype.toThe = function toThe(p) {
  const { w, vx, vy, vz } = this;

  // Avoid division by zero, or arccos of something not in its domain
  if (w >= (1 - 1e-6)) {
    return new Quaternion(1, 0, 0, 0);
  } else if (w <= (-1 + 1e-6)) {
    return new Quaternion(-1, 0, 0, 0);
  }

  const theta = Math.acos(w) // okay, since magnitude is 1, so -1 <= w <= 1
    * p;
  const axis = new Vector(vx, vy, vz).withMagnitude(Math.sin(theta));
  return new Quaternion(
    Math.cos(theta),
    axis.x,
    axis.y,
    axis.z
  );
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:430
 * @returns Quaternion
 */
Quaternion.prototype.inverse = function inverse() {
  return new Quaternion(
     this.w,
    -this.vx,
    -this.vy,
    -this.vz
  )
    .withMagnitude(1); // not that the normalize should be reqd
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:459
 * @param Quaternion b
 * @returns Quaternion
 */
Quaternion.prototype.times = function times(b) {
  const { w, vx, vy, vz } = this;

  const sa = w;
  const sb = b.w;
  const va = new Vector(vx, vy, vz);
  const vb = new Vector(b.vx, b.vy, b.vz);

  const vr = vb.scaledBy(sa).plus(va.scaledBy(sb).plus(va.cross(vb)));
  return new Quaternion(
    (sa * sb) - va.dot(vb),
    vr.x,
    vr.y,
    vr.z
  );
};

/**
 * definition from dsc.h:
 * implementation from util.cpp:475
 * @returns Quaternion
 */
Quaternion.prototype.mirror = function mirror() {
  return new Quaternion(
    this.rotationU().scaledBy(-1),
    this.rotationV().scaledBy(-1)
  );
};

module.exports = Quaternion;
